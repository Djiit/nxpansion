import { promises } from 'fs';
import { join } from 'path';
import childProcess = require('child_process');

/**
 * This e2e test builds the example apps in the repository, dumping the spans generated by the builds
 * to a JSON file, and testing that the spans that were generated are appropriate.
 */

const buildExampleApp = () => {
  return new Promise<void>((resolve, reject) => {
    childProcess.exec('yarn nx build example-app --runner otel-e2e', (err) => {
      err ? reject(err) : resolve();
    });
  });
};

const buildExampleApps = () => {
  return new Promise<void>((resolve, reject) => {
    childProcess.exec(
      'yarn nx run-many --target=build --projects=example-app,example-app-2 --runner otel-e2e',
      (err) => {
        err ? reject(err) : resolve();
      }
    );
  });
};

const printTraceParent = () => {
  return new Promise<string>((resolve, reject) => {
    childProcess.exec(
      'yarn nx print-trace-parent example-app --runner otel-e2e',
      (err, stdout) => {
        err ? reject(err) : resolve(stdout);
      }
    );
  });
};

interface WrittenSpan {
  traceId: string;
  parentId: string;
  name: string;
  id: string;
  kind: string;
  timestamp: number;
  duration: number;
  attributes: Record<string, string>;
  status: string;
  events: string;
}

describe('@nxpansion/opentelemetry-nx-runner', () => {
  describe('build one application', () => {
    let spans: WrittenSpan[];
    let rootSpan: WrittenSpan;
    beforeAll(async () => {
      await buildExampleApp();

      const spansStr = await promises.readFile(
        join(__dirname, 'tmp/spans.json'),
        'utf8'
      );

      spans = JSON.parse(spansStr);

      spans.forEach((span) => {
        if (!span.parentId) {
          rootSpan = span;
        }
      });
    });
    it('should capture a root span that represent the command being executed', async () => {
      expect(rootSpan.name).toEqual('nx-command');

      expect(rootSpan.attributes['command.target']).toEqual('build');
      expect(rootSpan.attributes['command.initiatingProject']).toEqual(
        'example-app'
      );
    });

    it('should capture a span for each project being built', async () => {
      const buildableProjects = ['example-app'];

      buildableProjects.forEach((project) => {
        const span = spans.find(
          (span) => span.attributes['task.target.project'] === project
        );

        expect(span.parentId).toEqual(rootSpan.id);

        expect(span.attributes['task.id']).toEqual(`${project}:build`);
        expect(span.attributes['task.target.target']).toEqual(`build`);
        // this could vary depending on the cache state of the machine
        expect(span.attributes['task.status']).toBeDefined();
      });
    });
  });

  describe('build multiple applications', () => {
    let spans: WrittenSpan[];
    let rootSpan: WrittenSpan;
    beforeAll(async () => {
      await buildExampleApps();

      const spansStr = await promises.readFile(
        join(__dirname, 'tmp/spans.json'),
        'utf8'
      );

      spans = JSON.parse(spansStr);

      spans.forEach((span) => {
        if (!span.parentId) {
          rootSpan = span;
        }
      });
    });
    it('should capture a root span that represent the command being executed', async () => {
      expect(rootSpan.name).toEqual('nx-command');

      expect(rootSpan.attributes['command.target']).toEqual('build');
      // initiating project is not set on run many commands
      expect(rootSpan.attributes['command.initiatingProject']).toEqual(
        undefined
      );
    });

    it('should capture a span for each project being built', async () => {
      const buildableProjects = ['example-app', 'example-app-2'];

      buildableProjects.forEach((project) => {
        const span = spans.find(
          (span) => span.attributes['task.target.project'] === project
        );

        expect(span.parentId).toEqual(rootSpan.id);

        expect(span.attributes['task.id']).toEqual(`${project}:build`);
        expect(span.attributes['task.target.target']).toEqual(`build`);
        // this could vary depending on the cache state of the machine
        expect(span.attributes['task.status']).toBeDefined();
      });
    });
  });
});
